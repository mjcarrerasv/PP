
##
C2
Here we re-write the code as a function of the order, n, vs the folder C1 where the code is a function of sp.
Here the timing is: shocks (nu and lam) are realized, then decisions are made
There are two inputs and only foreign inputs face dtimes and have inventories


##
C3
parallel via distributed the C2 code
 options are threds and distributed
 Distributed requires you to establish workers and create everywhere vs shared variables

 Distributed is faster than Threads (almost double...)

 Plus include a code with n_grid 

##
C4
Now I add domestic and foreign inventories with parallel distributed code.
Plus include an n_grid for each input. Faster? Not really. Better with the function of nu

## C6 (inside the C4 folder)
Two inputs, domestic and foreign inventories.
Code parallel and written as a function of n 
BUT TIMING is different: first choose n, then shocks are realized: Better and faster
Note: bounds for N! They are wrong in C4. I can't change sp to ensure bounds are met. 
Instead n:
#nfmax::Float64 = (sfgrid[sgridsize]/(1 - delta)) - sf + xf_unc
#ndmax::Float64 = (sdgrid[sgridsize]/(1 - delta)) - sd + xd_unc
nfmax::Float64 = (sfgrid[sgridsize]/(1 - delta)) - sf
ndmax::Float64 = (sdgrid[sgridsize]/(1 - delta)) - sd

Also don't change sgrid with the change in parameters

## C5
Three inputs, two inventories
Timing: shocks are realized, all decisions are made
Incorrect bounds for n and sp.



